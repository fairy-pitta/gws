# ADR-002: ポート割り当てアルゴリズム

## ステータス

Accepted

## コンテキスト

各ブランチ/サービスの組み合わせにユニークなポートが必要。要件:

1. **決定論的** - 同じブランチ/サービスは再起動しても同じポートを得るべき
2. **衝突処理** - 複数のブランチが同じポートにハッシュされる可能性
3. **範囲設定可能** - 異なるサービスに異なるポート範囲が必要かもしれない
4. **永続化** - 割り当ては再起動後も保持されるべき

ランダム割り当てだと再起動のたびにポートが変わり、ブックマークやハードコードされた URL が壊れる。

## 決定

linear probing 付きの FNV-32a ハッシュベース割り当てを採用:

```go
func hashPort(branch, service string, minPort, maxPort int) int {
    h := fnv.New32a()
    h.Write([]byte(branch + ":" + service))
    rangeSize := maxPort - minPort + 1
    return minPort + int(h.Sum32()) % rangeSize
}
```

衝突解決:
1. まずハッシュされたポートを試す
2. 使用中なら port+1, port+2, etc. を試す（linear probing）
3. maxPort でラップアラウンド
4. 全ポートが埋まっていたらエラー

永続化:
- `~/.portree/state.json` に割り当てを保存
- 再ハッシュの前に、以前割り当てたポートがまだ有効か確認

## 結果

### 良い点
- **決定論的** - `feature/auth` は常に同じポートを得る（衝突がなければ）
- **シンプルな実装** - FNV-32a は高速で分布が良い
- **予測可能** - ユーザーは自分のブランチのポートを覚えられる

### 悪い点
- **TOCTOU レース** - チェックとバインドの間にポートが取られる可能性（ファイルロックで軽減）
- **範囲枯渇** - ブランチが多すぎると割り当てが失敗する
- **linear probing のクラスタリング** - 衝突が多いとシーケンシャル割り当てに退化
